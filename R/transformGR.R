#' @import methods
#' @import flowWorkspace
#' @import openCyto
#' @import ggcyto
#' @import parallel
#' @import RColorBrewer
#' @import gtools
#' @import gridExtra
#' @import grid
#' @import methods
#' @import flowCore
#' @import ncdfFlow
#' @import RcppArmadillo
#' @import BH
#' @import ggplot2
# fs needs to have colnames: G, R, (B), S.A
# vars minmaxTrunc, multiplyBy, nanTrunc are assigned to global environment, but immediately removed
# this prevents issue with transforms on flowsets not finding objects when used within closure

transformGR <- function(fs, scaleBy=100000, minNormFluor=-1000, ratioRange=10, logicleMin=-0.5) {
scaleBy=100000
minNormFluor=-1000
ratioRange=10
logicleMin=-0.5

#default helper values
scaleBy <- scaleBy #factor to scale ssc normalized fluorescence to match original scale of fluorescence
minNormFluor <- minNormFluor #minimum G.n,R.n,B.n cutoff to avoid extreme neg values generated by scaling, only important for logicle estimation

ratioRange <- ratioRange #expected range of log10(R.n/G.n), only needed for auto plotting
logicleMin <- logicleMin #expected minimum value of logicle(G.n,R.n,B.n), only needed for auto plotting

# normalize by SSC
cat("Normalizing by SSC...")
assign("multiplyBy", multiplyTransform(transformationId="multiplyBy", a=scaleBy), pos = .GlobalEnv)
fs <- transform(fs, G.n = multiplyBy(G/S.A), R.n = multiplyBy(R/S.A)) #, B.n = scaleBy*(B/S.A))
remove("multiplyBy", pos = .GlobalEnv)

cat("Done\n")

# extract fluor total and R:G fluor ratio as log
cat("Calculating R:G ratio and total...")
fs <- transform(fs, fTotal = log10(G.n+R.n), fRatio = log10(R.n/G.n))
cat("Done\n")

# clean up min max for better plotting and logicle transform
p <- parameters(fs[[1]])
gfpIndex <- which(colnames(fs)=="G")
rfpIndex <- which(colnames(fs)=="R")
#bfpIndex <- which(colnames(fs)=="B")
G.nIndex <- which(colnames(fs)=="G.n")
R.nIndex <- which(colnames(fs)=="R.n")
#B.nIndex <- which(colnames(fs)=="B.n")
fTotalIndex <- which(colnames(fs)=="fTotal")
fRatioIndex <- which(colnames(fs)=="fRatio")
p[['maxRange']][G.nIndex] <- p[['maxRange']][gfpIndex]
p[['maxRange']][R.nIndex] <- p[['maxRange']][rfpIndex]
#p[['maxRange']][B.nIndex] <- p[['maxRange']][bfpIndex]
p[['maxRange']][fTotalIndex] <- log10(p[['maxRange']][gfpIndex] + p[['maxRange']][rfpIndex])
p[['maxRange']][fRatioIndex] <- ratioRange/2
p[['minRange']][G.nIndex] <- p[['minRange']][gfpIndex]
p[['minRange']][R.nIndex] <- p[['minRange']][rfpIndex]
#p[['minRange']][B.nIndex] <- p[['minRange']][bfpIndex]
p[['minRange']][fTotalIndex] <- 0
p[['minRange']][fRatioIndex] <- -ratioRange/2
L <- length(fs)
res <- mapply(1:L, FUN = function(x){parameters(fs[[x]]) <- p})

# clean up extreme and NaN values produced by division
assign("minmaxTrunc", minmaxTransform(transformationId="minmaxTrunc", a=minNormFluor, b=p[['maxRange']][gfpIndex]), pos = .GlobalEnv)
fs <- transform(fs, G.n=minmaxTrunc(G.n), R.n=minmaxTrunc(R.n)) #, B.n=minmaxTrunc(B.n))
remove("minmaxTrunc", pos = .GlobalEnv)

assign("nanTrunc", nanTransform(transformationId="nanTrunc", a=minNormFluor), envir = .GlobalEnv)
fs <- transform(fs, G.n=nanTrunc(G.n), R.n=nanTrunc(R.n))
remove("nanTrunc", pos = .GlobalEnv)

# transform with Logicle transform
cat("Logicle transform of G,R ...")
transFuncts <- estimateLogicle(fs[[1]], channels = c("G.n", "R.n")) #, "B.n"))
fs <- transform(fs, transFuncts)
cat("Done\n")

#clean up minRange after logical transform
p <- parameters(fs[[1]])
p[['minRange']][G.nIndex] <- logicleMin
p[['minRange']][R.nIndex] <- logicleMin
#p[['minRange']][B.nIndex] <- logicleMin
L <- length(fs)
res <- mapply(1:L, FUN = function(x){parameters(fs[[x]]) <- p})

# clean up desc column (marker names) automatically generated by transform()
chnls <- colnames(fs)
markers <- rep(NA_character_,length(chnls)) # use R's NA character value
names(markers) <- chnls
markernames(fs) <- markers

return(fs)

}