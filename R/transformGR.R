
transformGR <- function(fs, scaleBy=100000, minNormFluor=-1000, ratioRange=10, logicleMin=-0.5) {
scaleBy=100000
minNormFluor=-1000
ratioRange=10
logicleMin=-0.5

#default helper values
scaleBy <- scaleBy #factor to scale ssc normalized fluorescence to match original scale of fluorescence
minNormFluor <- minNormFluor #minimum G.n,R.n,B.n cutoff to avoid extreme neg values generated by scaling, only important for logicle estimation

ratioRange <- ratioRange #expected range of log10(R.n/G.n), only needed for auto plotting
logicleMin <- logicleMin #expected minimum value of logicle(G.n,R.n,B.n), only needed for auto plotting

# normalize by SSC
cat("Normalizing by SSC...")
fs <- transform(fs, G.n = scaleBy*(G/S.A), R.n = scaleBy*(R/S.A)) #, B.n = scaleBy*(B/S.A))

#fs <- do.call("transform", list(fs, G.n = scaleBy*(G/S.A), R.n = scaleBy*(R/S.A)))
cat("Done\n")

# extract fluor total and R:G fluor ratio as log
cat("Calculating R:G ratio and total...")
fs <- transform(fs, fTotal = log10(G.n+R.n), fRatio = log10(R.n/G.n))
cat("Done\n")

# clean up min max for better plotting and logicle transform
p <- parameters(fs[[1]])
G.nIndex <- which(colnames(fs)=="G.n")
R.nIndex <- which(colnames(fs)=="R.n")
#B.nIndex <- which(colnames(fs)=="B.n")
fTotalIndex <- which(colnames(fs)=="fTotal")
fRatioIndex <- which(colnames(fs)=="fRatio")
p[['maxRange']][G.nIndex] <- p[['maxRange']][gfpIndex]
p[['maxRange']][R.nIndex] <- p[['maxRange']][rfpIndex]
#p[['maxRange']][B.nIndex] <- p[['maxRange']][bfpIndex]
p[['maxRange']][fTotalIndex] <- log10(p[['maxRange']][gfpIndex] + p[['maxRange']][rfpIndex])
p[['maxRange']][fRatioIndex] <- ratioRange/2
p[['minRange']][G.nIndex] <- p[['minRange']][gfpIndex]
p[['minRange']][R.nIndex] <- p[['minRange']][rfpIndex]
#p[['minRange']][B.nIndex] <- p[['minRange']][bfpIndex]
p[['minRange']][fTotalIndex] <- 0
p[['minRange']][fRatioIndex] <- -ratioRange/2
L <- length(fs)
res <- mapply(1:L, FUN = function(x){parameters(fs[[x]]) <- p})

# clean up extreme and NaN values produced by division
minmaxTrunc <- minmaxTransform(transformationId="minmaxTrunc", a=minNormFluor, b=p[['maxRange']][gfpIndex])
fs <- transform(fs, G.n=minmaxTrunc(G.n), R.n=minmaxTrunc(R.n)) #, B.n=minmaxTrunc(B.n))

nanTrunc <- nanTransform(transformationId="nanTrunc", a=minNormFluor)
fs <- transform(fs, G.n=nanTrunc(G.n), R.n=nanTrunc(R.n))


# transform with Logicle transform
cat("Logicle transform of G,R ...")
transFuncts <- estimateLogicle(fs[[1]], channels = c("G.n", "R.n")) #, "B.n"))
fs <- transform(fs, transFuncts)
cat("Done\n")

#clean up minRange after logical transform
p <- parameters(fs[[1]])
p[['minRange']][G.nIndex] <- logicleMin
p[['minRange']][R.nIndex] <- logicleMin
#p[['minRange']][B.nIndex] <- logicleMin
L <- length(fs)
res <- mapply(1:L, FUN = function(x){parameters(fs[[x]]) <- p})

# clean up desc column (marker names) automatically generated by transform()
chnls <- colnames(fs)
markers <- rep(NA_character_,length(chnls)) # use R's NA character value
names(markers) <- chnls
markernames(fs) <- markers

return(fs)

}